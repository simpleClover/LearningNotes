# 第3章 处理数据

## 3.1 简单变量

为了将信息储存到计算机中，程序必须记录三个变量的三个属性
- 信息要储存在哪里
- 信息要储存什么值
- 要储存何种信息的值

假如有如下语句
```cpp
int braincount;
braincount = 5;
```
这些语句告诉程序，`braincount`储存的是一个`int`类型的变量，并将`5`复制到该内存中

可以使用`&`符号来检索`braincount`的内存地址

### 3.1.1 变量名

C++提倡使用有一定含义的变量名，以下是几条C++命名规则
- 在名称中只能使用字母字符、数字和下划线`_`
- 名称的第一个字符不能是数字
- 区分大小写字母
- 不能将C++关键字用作名称
- 以两个下划线或下划线和大写字母打头的名称被保留给实现使用，以一个下划线开头的名称被保留给实现，用作全局标识符
- C++对于名称的长度没有限制，但有些平台会有长度限制

### 3.1.2 整型

整数就是没有小数部分的数字。不同C++整型使用不同的内存量来储存整数，使用的内存越大，可以表示的整数范围也越大  
C++的基本类型有`char`、`short`、`int`、`long`和`long long`，其中每种类型都有**有符号版本**和**无符号版本**，因此总共有十种类型可以选择

### 3.1.3 整型short、int、long和long long

计算机内存由位(bit)组成，C++的short、int、long和long long类型通过使用不同数目的位来储存值，最多能够表示四种不同的整数宽度。  
为了满足所有的计算机设计要求。C++提供了一种灵活的标准，它确保了最低长度
- short至少16位长
- int至少和short一样长
- long至少32位，且至少与int一样长
- long long至少64位长，且至少与long一样长

头文件`climits`中包含了关于整数限制的信息，例如`INT_MAX`为int的最大取值，`CHAR_BIT`为字节的位数

`sizeof`运算符将返回相应类型占用的字节数。如对int类型使用sizeof运算符时，应将名称放在括号中`sizeof(int)`

#### 初始化

初始化将赋值和声明语句放在一起。例如`int a=10`和`int a(10)`  
还有另外一种初始化方法，这种方式用于数组和结构，但是在C++98中也适用于单值变量`int a = {5};`  
其次，大括号内可以不包含任何东西，这种情况下变量将被初始化为0 

### 3.1.4 无符号类型

前面介绍的四种整型都有一种不能储存负数值的无符号变体，其特点是可以增大变量能够储存的最大值。例如，如果short表示的范围为-32768到+32767，那么无符号版本的表示范围为0到65535。  
要创建无符号版本的基本整型，只需要使用关键字unsigned来修饰变量即可


### 3.1.5 选择整型数据

C++提供了大量整型，通常int被设置为对目标计算机而言最自然的长度。如果没有非常有说服力的理由来选择其他类型，则应使用int  
如果变量表示的值不可能为负，例如文档中的字数，则可以使用无符号类型  
如果变量可能表示的整数可能大于16位整数的最大可能值，应该使用long，如果超过22亿，则应该使用long long  
如果short比int小，则使用short可以节省内存。通常当有大型整型数组的时候，才有必要使用short  
如果只需要一个字节，可使用char

### 3.1.6 整型字面值

整型字面值为显式书写的常量，例如`212`或`1776`  
与C相同，C++可以用三种不同的技术方式书写整型：基数为10，基数为8和基数为16  
C++使用前一（两）位来表示字符常量的基数
- 如果第一位为1~9，则基数为10
- 如果第一位为0，第二位为1~7，则基数为8
- 如果前两位为0x或0X，则基数为16

默认情况下，cout以十进制格式显示整数，但是可以使用dec、hex和oct控制符修改输出进制格式，在下一次修改格式之前，原来的格式将一直有效
```cpp
#include <iostream>
using namespace std;
int main(){
    int chest = 42;
    cout << "chest = " << chest << endl;
    cout << hex;
    cout << "chest = " << chest << endl;
    cout << oct;
    cout << "chest = " << chest << endl;
    return 0;
}
```
输出：
```
chest = 42
chest = 2a
chest = 52
```

### 3.1.7 C++如何确定常量的类型

C++默认将整型常量存储为int类型  

整型后面的l或者L后缀表示该整数为long常量，u或U后缀表示`unsigned int`常量，ul（与顺序，大小写无关）表示`unsigned long`常量  
C++提供了用于表示类型`long long`的后缀ll和LL，还提供了用于表示`unsigned long long`类型的ull、Ull、uLL和ULL  
在C++中对于不带后缀的十进制整数，将使用`int`、`long`或`long long`中能储存这个数的最小类型表示，对于不带后缀的八进制或十六进制整数，将使用`int`、`unsigned int`、`long`、`unsigned long`、`long long`或`unsigned long long`中能储存该数的最小类型来表示

### 3.1.8  char类型：字符和小整数

char类型是专为储存字符而设计的。它足够长，能够表示目标计算机系统中的所有基本符号——所有的字母、数字、标点符号等。  
```cpp
#include <iostream>
using namespace std
int main(){
    char ch = 'M';
    int i = ch;
    cout << "字符 " << ch << " 的ASCII码为 " << i << endl;
    cout << "对字符加一" << endl;
    ch = ch + 1;
    i = ch;
    cout << "字符 " << ch << " 的ASCII码为 " << i << endl;
    cout << "使用cout.put()输出字符:";
    cout.put(ch);
    cout.put('!');
    cout << endl << "Done" << endl;
    return 0;
}
```
输出：
```
字符 M 的ASCII码为 77
对字符加一
字符 N 的ASCII码为 78
使用cout.put()输出字符:N!
Done
```

#### char字面值
在C++中书写字符常量的方式有很多种。对于常规字符（如数字、字母和标点符号），最简单的方法是将字符用单引号括起。这种方式表示代表的是字符的数值编码
- 'A'为65，即字符A的ASCII码
- 'a'为97，即字符a的ASCII码

#### 转义序列
有些字符不能直接通过键盘输入到程序中。对于这些字符，C++提供了一种特殊的表示方法－－转义序列

字符名称|ASCII符号|C++代码|十进制ASCII码|十六进制ASCII码
:-:|:-:|:-:|:-:|:-:
换行符|NL(LF)|\n|10|0xA
水平制表符|HT|\t|9|0x9
垂直制表符|VT|\v|11|0xB
退格|BS|\b|8|0x8
回车|CR|\r|13|0xD
响铃|BEL|\a|7|0x7
反斜杠| \\ | \\\\ |92|0x5C
问号|?|\?|63|0x3F
单引号|'|\'|39|0x27
双引号|"|\"|34|0x22

注意：应该像处理常规字符那样处理转义字符，也就是说，将它们作为字符常量的时候，应用单引号括起，将它们放在字符串的时候，不要使用单引号

#### 通用字符名

通用字符名的用法类似转义序列。通用字符名可以以`\u`或`\U`打头。`\u`后面是8个十六进制位，`\U`后面则是16个十六进制位。这些位表示的是字符的ISO 10646码点

#### signed char 和 unsigned char
与int不同的是，char在默认情况下是否有符号与C++实现决定。如果char有某种特定的行为对你来说非常重要，则可以显式地将类型设置为`unsigned char`或`signed char`  
如果使用char作为数值类型，那么`unsigned char`和`signed char`表示的范围分别是`0~255`和`－128~127`  
如果使用char作为变量来储存ASCII字符，那么使用char就可以了

#### wchar_t
程序需要处理的字符集可能不能用一个8位的字节表示，如日文汉字系统。对于这种情况，可以使用`wchar_t`（宽字符类型）  
cin和cout将输入和输出看作是char流，因此不适合处理wchar_t类型，使用wcin和wcout来处理wchar_t流  
可以通过加上前缀L来指示宽字符常量和宽字符串
```cpp
wchar_t bob = L'P';
wcout << L"tall" << endl;
```

#### C++11新增类型:char16_t和char32_t
前者长16位，无符号，后者长32位，也无符号  
C++使用前缀`u`表示`char16_t`字符常量和字符串常量，用前缀`U`表示`char32_t`字符常量和字符串常量

### 3.1.9 bool类型

ANSI/ISO C++标准添加了一种叫做bool的新类型。在计算中，布尔变量的值可以是true或false，C++将非零值解释为true，将零解释为false。字面值true和false都可以通过提升转换为int类型，true转换为1，false转换为0

## 3.2 const限定符

const限定符可用于创建常量，创建格式为`const type name = value;`  
若要定义一个常量，那么必须在定义的时候完成初始化，因为你无法修改一个常量的值

## 3.3 浮点数

浮点数是C++的第二组基本类型，使用浮点数可以表示诸如2.5、3.1415926这样的数字，计算机将会把这些数字分成两部分储存。一部分表示值，另一部分用于对值进行放大或缩小

### 3.3.1 书写浮点数

C++有两种书写浮点数的方法，第一种是使用标准小数表示法  
例如`12.34`、`9598.120`、`0.00023`、`0.0`  
另一种则是使用E表示法，这种写法适合非常大或者非常小的数  
例如2.52E+3、-3.4e10、1.233E-10

### 3.3.2 浮点类型

C++有3种浮点类型：`float`、`double`和`long double`，C++对于位数的要求是`float`至少32位，`double`至少48位，而且不少于`float`，`long double`至少和`double`一样多  
通常，`float`为32位，`double`为64位，`long double`为80、92或128位

### 3.3.3 浮点常量

在程序种书写浮点常量的时候，程序默认会将其归于`double`类型，如果希望常量为`float`类型，请使用`f`或`F`后缀，对于`long double`类型，可以使用`l`或`L`后缀

### 3.3.4 浮点数的优缺点

与整数相比，浮点数可以表示整数之间的值，同时有更大的表示范围  
但是浮点运算的速度通常比整数慢，而且精度将降低

## 3.4 C++算数运算符

C++使用运算符来运算。它提供了几种运算符来完成5种基本的算术计算：加减乘除以及取模  
- `+`运算符对操作数执行加法操作
- `-`运算符从第一个数中减去第二个数
- `*`运算符将操作数相乘
- `/`运算符用第一个数除以第二个数，如果两个数都是整数，则结果为商的整数部分，例如17/3等于5，小数部分被丢弃
- `%`运算符求模，两个操作数**必须为整型**。如果其中一个是负数，则结果的符号满足如下规则：`(a/b)*b+a%b=a`

### 3.4.1 运算符优先级和结合性

C++使用优先级规则来决定首先使用哪个运算符。算术运算符遵守通常的代数优先级，先乘除后加减，因此3+4*5指的是3+(4*5)  
当两个运算符优先级相同时，C++将看运算符的结合性是从左到右还是从右到左，从左到右的揭黑选哪个意味着如果两个优先级相同的运算符被同时用于结合同一个操作数，则首先应用左侧的运算符。从右到左的结合性则优先使用右侧的运算符

### 3.4.2 除法分支

除法运算符的行为取决于操作数的类型，如果两个操作数都是整数，则C++将执行整数除法。这意味着结果的小数点部分被丢弃，使得最后的一个结果是整数，如果其中有至少一个是浮点数，则小数部分将被保留，结果为浮点数

### 3.4.3 求模运算符

求模运算符返回整数除法的余数

### 3.4.4 类型转换

C++丰富的类型允许根据需求使用不同的类型，这使得计算机的操作更为复杂。由于有11种整型和3种浮点类型，因此计算机需要处理大量不同情况，尤其是不同类型进行运算时。为了处理这种潜在的混乱，C++自动执行很多类型转换
- 将一种算数类型的值赋值给另外一种算数类型的变量时，C++将对其值进行转换
- 表达式中包含不同的类型时，C++将对值进行转换
- 将参数传递给函数时，C++将对值进行转换

C++允许将一种类型的值赋给另一种类型的变量。这样做时，值将 被转换为接收变量的类型。例如，假设so_long的类型为long，thirty的类型为short。
```
so_long = thirty;
```
则进行赋值时，程序将thirty的值扩展为long的长度

将一个值赋给值取值范围更大的类型通常不会导致什么问题。如，将short值赋给long变量并不会改变这个值，只是占用的字节更多而 已。然而，将一个很大的long值（如2111222333）赋给float变量将降低 精度。因为float只有6位有效数字，因此这个值将被四舍五入为 2.11122E9。因此，有些转换是安全的，有些则会带来麻烦。

转 换|潜在的问题
:-|:-
将较大的浮点类型转换为较小的浮点类型，如将double转换为float|精度（有效位数）降低，值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的
将浮点数转换为整型|小数部分丢失，原来的值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的
将较大的整型转换为较小的整型，如将long转换为short|原来的值可能超出目标类型的取值范围，通常只复制右边的字节

将0赋值给bool变量时，将被转换为false；非零值则会被转换成true

当同一个表达式中包含两种不同的算术类型时，C++将执行两种自动转换：首先，一些类型在出现时便会自动转换；其次，有些类型在与其他类型同时出现在表达式中时将被转换
- 在计算表达式时，C++将`bool`、`char`、`unsigned char`、`signed char`和`short`值转换为`int`。具体地说，true被转换为1，false 被转换为0。这些转换被称为整型提升（integral promotion）
- wchar_t被提升成为下列类型中第一个宽度足够存储`wchar_t`取值范围的类型：`int`、`unsigned int`、`long`或`unsigned long`
- 将不同类型进行算术运算时，也会进行一些转换，例如将int和float 相加时。当运算涉及两种类型时，较小的类型将被转换为较大的类型
- 传递参数时的类型转换通常由C++函数原型控制
- C++还允许通过强制类型转换机制显式地进行类型转换
    ```
    (typeName) value  
    typeName (value)
    ```
第二种格式的想法是，要让强制类型转换就像是函数调用。这样对内置类型的强制类型转换就像是为用户定义的类设计的类型转换。

更安全的转换方式是使用`static_cast<typeName> (value)`函数。

Stroustrup认为，C语言式的强制类型转换由于有过多的可能性而极其危险，这将在第15章更深入地讨论。运算符static_cast<>比传统强制类型转换更严格。

### 3.4.5 C++11中的auto声明

在初始化声明中，如果使用关键字auto，而不指定变量的类型，编译器将把变量的类型设置成与初始值相同

处理复杂类型，如标准模块库（STL）中的类型时，自动类型推断的有时才能显现出来。例如，对于下述C++98代码:
```cpp
std::vector<double> scores;
std::vector<double>::iterator pv = scores.begin();
```
C++11允许您将其重写为下面这样:
```cpp
std::vector<double> scores;
auto pv = scores.begin();
```

## 3.5 总结
- C++的基本类型分为两组：一组由存储为整数的值组成，另一组由存储为浮点格式的值组成。整型之间通过存储值时使用的内存量及有无符号来区分
- 整型从最小到最大依次是：bool、char、signed char、unsigned char、short、unsigned short、int、unsigned int、long、unsigned long以及C++11新增的long long和unsigned long long
- 还有一种wchar_t 类型，它在这个序列中的位置取决于实现。C++11新增了类型char16_t和char32_t，它们的宽度足以分别存储16和32位的字符编码。C++确保了char足够大，能够存储系统基本字符集中的任何成员，而wchar_t则可以存储系统扩展字符集中的任意成员
- short至少为16位，而int至少与short一样长，long至少为32位，且至少和int一样长。确切的长度取决于实现
- 浮点类型可以表示小数值以及比整型能够表示的值大得多的值
- 3种浮点类型分别是float、double和long double
- C++确保float不比double 长，而double不比long double长。通常，float使用32位内存，double使用 64位，long double则使用80到128位。
- 对变量赋值、在运算中使用不同类型、使用强制类型转换时，C++将把值从一种类型转换为另一种类型。
